/**
 * Remote Access VPN Configuration Generators
 *
 * Generates FortiGate IPSEC VPN + Entra ID SAML configuration output
 * in four formats: CLI Script, GUI Steps, Azure Setup, FortiClient XML.
 *
 * Ported from fortigatevpngenerator-index.html (genCLI, genGUI, genAZ, genXML).
 */

import type { IPsecRemoteAccessConfig } from '../../types';

// ===== Helper: escape backslashes and double-quotes for CLI strings =====
function esc(s: string): string {
  return (s || '').replace(/\\/g, '\\\\').replace(/"/g, '\\"');
}

// ---------------------------------------------------------------------------
// 1. CLI Script Generator
// ---------------------------------------------------------------------------
export function generateRemoteAccessCLI(config: IPsecRemoteAccessConfig): string {
  const tunnels = config.tunnels;
  const firstTunnel = tunnels[0];
  const fq = firstTunnel.fqdn || '{fqdn}';
  const pt = firstTunnel.port || '10428';

  // Shared settings across all tunnels
  const p1p = config.p1p.join(' ') || 'aes256-sha256';
  const dh = config.p1d.join(' ') || '19 20 21';
  const kl1 = config.p1kl || '86400';
  const nat = config.natTrav;
  const dpd = config.dpdOn;
  const di = config.dpdInt || '5';
  const dr = config.dpdRet || '3';
  const p2p = config.p2p.join(' ') || 'aes256-sha256';
  const pfs = config.pfsOn;
  const pfdh = config.pfsDh;
  const kl2 = config.p2kl || '43200';
  const sip = config.startIp || '{start-ip}';
  const eip = config.endIp || '{end-ip}';
  const dm = config.dnsMode;
  const d1 = config.dns1;
  const d2 = config.dns2;
  const sm = config.splitMode;
  const sn = config.splitNets.split('\n').map(l => l.trim()).filter(Boolean);
  const sgn = config.splitGrpName;
  const sName = config.samlName || '{saml-server}';
  const eL = config.eLoginUrl || '{login-url}';
  const eE = config.eEntityId || '{entity-id}';
  const eO = config.eLogoutUrl || '{logout-url}';
  const iCrt = config.idpCert || '{idp-cert}';
  const sCrt = config.srvCert || 'Fortinet_Factory';
  const userGrps = config.userGroups;
  const gid = userGrps[0]?.objId || '{group-object-id}';
  const gP1 = config.grpP1;
  const an = config.autoNeg;
  const ka = config.keepAlive;
  const cl = config.childless;
  const sp = config.savePw;
  const bn = config.banner;
  const psk = config.psk;
  const now = new Date().toISOString().replace('T', ' ').slice(0, 19);

  let o = `# ========================================
# FortiClient IPSEC VPN Configuration
# with Entra ID SAML Authentication
# FortiOS 7.4.11+
# Generated by FortiGate Config Wizard: ${now}
# ========================================

# ========================================
# PREREQUISITES - COMPLETE THESE FIRST
# ========================================
#
# 1. Import Entra ID SAML Certificate:
#    GUI: System > Certificates > Import > Remote Certificate
#    - Upload the Base64 certificate downloaded from Azure
#    - Certificate name on FortiGate: "${iCrt}"
#
# 2. Ensure FortiGate server certificate exists:
#    GUI: System > Certificates > Local Certificates
#    - Verify certificate "${sCrt}" exists
#    - For production: use a cert matching ${fq}
#
# 3. Obtain Azure Group Object ID:
#    Azure Portal > Microsoft Entra ID > Groups > [Your Group]
#    - Object ID: ${gid}
#
# ========================================

# === Global SAML Port Configuration ===
config system global
    set auth-ike-saml-port ${pt}
end

# === SAML Server Configuration ===
config user saml
    edit "${sName}"
        set cert "${sCrt}"
        set entity-id "https://${fq}:${pt}/remote/saml/metadata"
        set single-sign-on-url "https://${fq}:${pt}/remote/saml/login"
        set single-logout-url "https://${fq}:${pt}/remote/saml/logout"
        set idp-entity-id "${esc(eE)}"
        set idp-single-sign-on-url "${esc(eL)}"
        set idp-single-logout-url "${esc(eO)}"
        set idp-cert "${iCrt}"
        set user-name "username"
        set group-name "group"
    next
end

# === User Authentication Settings ===
config user setting
    set auth-cert "${sCrt}"
end

# === Interface SAML Server Binding ===
${[...new Set(tunnels.map(t => t.wanIf))].map(wanIf => `config system interface
    edit "${wanIf}"
        set ike-saml-server "${sName}"
    next
end`).join('\n\n')}

# === User Group Configuration ===
${userGrps.map(grp => `config user group
    edit "${grp.name}"
        set member "${sName}"
        config match
            edit 1
                set server-name "${sName}"
                set group-name "${grp.objId}"
            next
        end
    next
end`).join('\n\n')}
`;

  // === Split Tunnel Address Objects & Groups (BEFORE Phase 1) ===
  if (sm === 'enabled') {
    const customGrpName = sgn ? sgn.trim() : '';
    const hasSubnets = sn.length > 0;

    if (customGrpName && hasSubnets) {
      // Path 1: Custom name + subnets = Create new group with custom name
      o += `
# === Split Tunnel Address Objects ===
config firewall address`;
      sn.forEach((s, i) => {
        o += `
    edit "${customGrpName}_subnet_${i + 1}"
        set subnet ${s}
    next`;
      });
      o += `
end

# === Split Tunnel Address Group ===
config firewall addrgrp
    edit "${customGrpName}"
        set member ${sn.map((_, i) => '"' + customGrpName + '_subnet_' + (i + 1) + '"').join(' ')}
        set comment "Split tunnel protected networks"
    next
end
`;
    } else if (customGrpName && !hasSubnets) {
      // Path 2: Custom name + no subnets = Reference existing group (no creation)
      o += `
# === Split Tunneling ===
# Referencing existing address group: "${customGrpName}"
# (Group must already exist in FortiGate configuration)

`;
    } else if (!customGrpName && hasSubnets) {
      // Path 3: No custom name = Create per-tunnel groups (original behavior)
      o += `
# === Split Tunnel Address Objects ===`;
      tunnels.forEach((tunnel, tIdx) => {
        const tName = tunnel.name || 'tunnel' + tIdx;
        o += `
config firewall address`;
        sn.forEach((s, i) => {
          o += `
    edit "${tName}_subnet_${i + 1}"
        set subnet ${s}
    next`;
        });
        o += `
end

# === Split Tunnel Address Group for ${tName} ===
config firewall addrgrp
    edit "${tName}-split"
        set member ${sn.map((_, i) => '"' + tName + '_subnet_' + (i + 1) + '"').join(' ')}
        set comment "Split tunnel for ${tName}"
    next
end
`;
      });
    }
  }

  // === Phase 1 Configuration (Multiple Tunnels) ===
  o += `# === Phase 1 Configuration (Multiple Tunnels) ===
${tunnels.map(tunnel => {
    const tName = tunnel.name || '{tunnel-name}';
    const tComments = tunnel.comments || '';
    const tWan = tunnel.wanIf || 'wan1';

    // Determine which group name to reference in Phase 1
    const splitGrpRef = sgn ? sgn.trim() : (tName + '-split');

    return `config vpn ipsec phase1-interface
    edit "${tName}"
        # Basic Settings
        set type dynamic
        set interface "${tWan}"${tComments ? '\n        set comments "' + esc(tComments) + '"' : ''}
        set ike-version 2
        set peertype any

        # Encryption & Authentication
        set proposal ${p1p}
        set dhgrp ${dh}
        set keylife ${kl1}

        # Mode Config (IP Assignment)
        set net-device disable
        set mode-cfg enable
        set ipv4-start-ip ${sip}
        set ipv4-end-ip ${eip}
        set dns-mode ${dm}${dm === 'manual' && d1 ? '\n        set ipv4-dns-server1 ' + d1 : ''}${dm === 'manual' && d2 ? '\n        set ipv4-dns-server2 ' + d2 : ''}${sm === 'enabled' ? '\n        set ipv4-split-include "' + splitGrpRef + '"' : ''}

        # SAML Authentication
        set eap enable
        set eap-identity send-request${gP1 ? '\n        set authusrgrp "' + userGrps.map(g => g.name).filter(n => n).join('" "') + '"' : '\n        # NOTE: authusrgrp not set - apply user groups in firewall policies'}
        set childless-ike ${cl ? 'enable' : 'disable'}

        # Network & Advanced
        set nattraversal ${nat ? 'enable' : 'disable'}${dpd ? '\n        set dpd on-idle\n        set dpd-retrycount ' + dr + '\n        set dpd-retryinterval ' + di : '\n        set dpd disable'}${an ? '\n        set client-auto-negotiate enable' : ''}${ka ? '\n        set client-keep-alive enable' : ''}${sp ? '\n        set save-password enable' : ''}${bn ? '\n        set banner "' + esc(bn) + '"' : ''}
        set psksecret ${psk ? esc(psk) : 'ENC [auto-generated-placeholder]'}
    next
end`;
  }).join('\n\n')}

# === Phase 2 Configuration (Multiple Tunnels) ===
${tunnels.map(tunnel => {
    const tName = tunnel.name || '{tunnel-name}';

    return `config vpn ipsec phase2-interface
    edit "${tName}"
        set phase1name "${tName}"
        set proposal ${p2p}${pfs ? '\n        set pfs enable\n        set dhgrp ' + pfdh : '\n        set pfs disable'}
        set keylifeseconds ${kl2}
    next
end`;
  }).join('\n\n')}

# === Firewall Address for VPN Pool ===
config firewall address
    edit "VPN_Pool_Range"
        set type iprange
        set start-ip ${sip}
        set end-ip ${eip}
        set comment "Shared VPN IP pool for all tunnels"
    next
end`;

  o += `\n
# ========================================
# FIREWALL POLICIES
# ========================================

# === Policy 1: VPN to WAN (Internet Access) ===
config firewall policy
    edit 0
        set name "VPN-to-WAN"
        set srcintf ${tunnels.map(t => '"' + (t.name || '{tunnel-name}') + '"').join(' ')}
        set dstintf "wan1"
        set srcaddr "VPN_Pool_Range"
        set dstaddr "all"
        set action accept
        set schedule "always"
        set service "ALL"${gP1 ? '\n        # User groups enforced at tunnel level (Phase 1)' : '\n        set groups "' + userGrps.map(g => g.name).filter(n => n).join('" "') + '"'}
        set nat enable
        set utm-status enable
        set ips-sensor "default"
        set ssl-ssh-profile "certificate-inspection"
        set av-profile "default"
        set webfilter-profile "default"
        set application-list "default"
        set logtraffic all
    next
end

# === Policy 2: VPN to LAN (Internal Access) ===
config firewall policy
    edit 0
        set name "VPN-to-LAN"
        set srcintf ${tunnels.map(t => '"' + (t.name || '{tunnel-name}') + '"').join(' ')}
        set dstintf "internal"
        set srcaddr "VPN_Pool_Range"
        set dstaddr "all"
        set action accept
        set schedule "always"
        set service "ALL"${gP1 ? '\n        # User groups enforced at tunnel level (Phase 1)' : '\n        set groups "' + userGrps.map(g => g.name).filter(n => n).join('" "') + '"'}
        set nat disable
        set utm-status enable
        set ips-sensor "default"
        set ssl-ssh-profile "certificate-inspection"
        set av-profile "default"
        set webfilter-profile "default"
        set application-list "default"
        set logtraffic all
    next
end

# NOTE: Customize 'dstintf', 'dstaddr', and security profiles as needed
# Ensure security profiles exist: System > Security Profiles
# If using multiple WAN interfaces, adjust dstintf in Policy 1 accordingly
`;

  return o;
}

// ---------------------------------------------------------------------------
// 2. GUI Steps Generator
// ---------------------------------------------------------------------------
export function generateRemoteAccessGUI(config: IPsecRemoteAccessConfig): string {
  const tunnels = config.tunnels;
  const firstTunnel = tunnels[0];
  const fq = firstTunnel.fqdn || '{fqdn}';
  const pt = firstTunnel.port || '10428';
  const sName = config.samlName || '{saml-server}';
  const eL = config.eLoginUrl || '{login-url}';
  const eE = config.eEntityId || '{entity-id}';
  const eO = config.eLogoutUrl || '{logout-url}';
  const iCrt = config.idpCert || '{idp-cert}';
  const sCrt = config.srvCert || 'Fortinet_Factory';
  const userGrps = config.userGroups;
  const p1p = config.p1p.join(', ') || 'aes256-sha256';
  const dhg = config.p1d.join(', ') || '19, 20, 21';
  const kl1 = config.p1kl || '86400';
  const p2p = config.p2p.join(', ') || 'aes256-sha256';
  const pfs = config.pfsOn;
  const pfdh = config.pfsDh;
  const kl2 = config.p2kl || '43200';
  const sip = config.startIp || '{start-ip}';
  const eip = config.endIp || '{end-ip}';
  const dm = config.dnsMode;
  const d1 = config.dns1;
  const d2 = config.dns2;
  const nat = config.natTrav;
  const dpd = config.dpdOn;
  const sm = config.splitMode;
  const sn = config.splitNets.split('\n').map(l => l.trim()).filter(Boolean);
  const sgn = config.splitGrpName;
  const gP1 = config.grpP1;
  const now = new Date().toISOString().replace('T', ' ').slice(0, 19);

  let step = 0;
  let o = `========================================
STEP-BY-STEP GUI CONFIGURATION
FortiGate IPSEC VPN + Entra ID SAML
FortiOS 7.4.11+
Generated by FortiGate Config Wizard: ${now}
========================================
`;
  o += `
Step ${++step}: Import Entra ID Certificate
  1. Navigate to: System > Certificates
  2. Click: Import > Remote Certificate
  3. Upload the Base64 .cer file from Azure
  4. Note the certificate name: "${iCrt}"

Step ${++step}: Verify Server Certificate
  1. Navigate to: System > Certificates > Local Certificates
  2. Verify "${sCrt}" exists
  3. For production: use a cert matching ${fq}

Step ${++step}: Configure Global SAML Port (CLI)
  config system global
      set auth-ike-saml-port ${pt}
  end

Step ${++step}: Bind SAML Server to WAN Interfaces (CLI)
${[...new Set(tunnels.map(t => t.wanIf))].map(wanIf => `  config system interface
      edit "${wanIf}"
          set ike-saml-server "${sName}"
      next
  end`).join('\n\n')}

Step ${++step}: Configure SAML Server
  1. Navigate to: User & Authentication > Single Sign-On
  2. Click: Create New
  3. Configure:
     Name: ${sName}
     SP Certificate: ${sCrt}

     Service Provider URLs:
       Entity ID:  https://${fq}:${pt}/remote/saml/metadata
       ACS URL:    https://${fq}:${pt}/remote/saml/login
       SLO URL:    https://${fq}:${pt}/remote/saml/logout

     Identity Provider:
       Type: Custom
       Login URL:   ${eL}
       Entity ID:   ${eE}
       Logout URL:  ${eO}
       Certificate: ${iCrt}

     SAML Attributes:
       username: username
       group: group
  4. Click: OK

Step ${++step}: Configure User Groups
${userGrps.map((grp, idx) => `  ${idx + 1}. Navigate to: User & Authentication > User Groups
     Click: Create New
     Configure:
       Name: ${grp.name}
       Type: Firewall
       Remote Groups > Add:
         Server: ${sName}
         Groups: ${grp.objId}
     Click: OK`).join('\n\n')}

Step ${++step}: Configure Phase 1 Tunnels
${tunnels.map((tunnel, idx) => {
    const tName = tunnel.name || '{tunnel-name}';
    const tWan = tunnel.wanIf || 'wan1';
    const tComments = tunnel.comments || '';
    return `  ${tunnels.length > 1 ? 'Tunnel ' + (idx + 1) + ': ' + tName : ''}
  1. Navigate to: VPN > IPsec Wizard > Custom
  2. Configure:
     Name: ${tName}${tComments ? '\n     Comments: ' + tComments : ''}
     Remote Gateway: Dialup User
     Interface: ${tWan}
     IKE Version: 2
     NAT Traversal: ${nat ? 'Enable' : 'Disable'}
     DPD: ${dpd ? 'On Idle' : 'Disable'}

     Phase 1 Proposal:
       Encryption/Auth: ${p1p}
       DH Groups: ${dhg}
       Key Lifetime: ${kl1} seconds

     Apply via CLI after wizard:
       set eap enable
       set eap-identity send-request
       set childless-ike enable${gP1 ? '\n       set authusrgrp "' + userGrps.map(g => g.name).filter(n => n).join('" "') + '"' : ''}`;
  }).join('\n\n')}

Step ${++step}: Configure Phase 2 for Each Tunnel
  Phase 2 Proposal: ${p2p}
  PFS: ${pfs ? 'Enable (DH ' + pfdh + ')' : 'Disable'}
  Key Lifetime: ${kl2} seconds
  (Apply same settings to all tunnels)

Step ${++step}: Configure IP Address Pool
  1. Edit first tunnel: VPN > IPsec Tunnels > ${firstTunnel.name || '{tunnel-name}'}
  2. Mode Config: Enable
     Start IP: ${sip}
     End IP: ${eip}
     DNS Mode: ${dm}${dm === 'manual' ? '\n     Primary DNS: ' + (d1 || 'N/A') + (d2 ? '\n     Secondary DNS: ' + d2 : '') : ''}
  3. Click: OK
  (NOTE: IP pool is shared across all tunnels)`;

  // Split tunneling steps
  if (sm === 'enabled') {
    const customGrpName = sgn ? sgn.trim() : '';
    const hasSubnets = sn.length > 0;

    if (customGrpName && hasSubnets) {
      // Custom name with subnets - create new group
      o += `

Step ${++step}: Configure Split Tunnel (Custom Address Group: ${customGrpName})
  1. Navigate to: Policy & Objects > Addresses
  2. Create address objects for each subnet:
${sn.map((s, i) => `     Name: ${customGrpName}_subnet_${i + 1}
     Type: Subnet
     IP/Network Mask: ${s}`).join('\n')}
  3. Navigate to: Policy & Objects > Address Groups
  4. Create address group:
     Name: ${customGrpName}
     Members: ${sn.map((_, i) => customGrpName + '_subnet_' + (i + 1)).join(', ')}
  5. In each tunnel config via CLI:
     set ipv4-split-include "${customGrpName}"`;
    } else if (customGrpName && !hasSubnets) {
      // Reference existing group
      o += `

Step ${++step}: Configure Split Tunnel (Reference Existing Group)
  1. Ensure address group "${customGrpName}" exists in FortiGate
  2. In each tunnel config via CLI:
     set ipv4-split-include "${customGrpName}"`;
    } else if (!customGrpName && hasSubnets) {
      // Per-tunnel groups (original behavior)
      tunnels.forEach((tunnel, tIdx) => {
        const tName = tunnel.name || 'tunnel' + tIdx;
        o += `

Step ${++step}: Configure Split Tunnel for ${tName}
  1. Create address objects:
${sn.map((s, i) => `     ${tName}_subnet_${i + 1}: ${s}`).join('\n')}
  2. Create address group: ${tName}-split
  3. In tunnel config: set ipv4-split-include "${tName}-split"`;
      });
    }
  }

  o += `

Step ${++step}: Create Firewall Policy
  1. Policy & Objects > Firewall Policy > Create New
     Name: VPN-to-LAN
     Incoming: ${tunnels.map(t => t.name || '{tunnel-name}').join(', ')}
     Outgoing: internal
     Source: VPN_Pool_Range
     Destination: [Your LAN networks]
     Action: ACCEPT
     Service: ALL${gP1 ? '\n     (User groups enforced at tunnel level)' : '\n     User Groups: ' + userGrps.map(g => g.name).filter(n => n).join(', ')}

Step ${++step}: Verify
  1. Dashboard > VPN: Confirm all tunnels are up
  2. Test with FortiClient using Entra ID credentials
`;

  return o;
}

// ---------------------------------------------------------------------------
// 3. Azure / Entra ID Setup Generator
// ---------------------------------------------------------------------------
export function generateRemoteAccessAzure(config: IPsecRemoteAccessConfig): string {
  const tunnels = config.tunnels;
  const firstTunnel = tunnels[0];
  const fq = firstTunnel.fqdn || '{fqdn}';
  const pt = firstTunnel.port || '10428';
  const eL = config.eLoginUrl || '{login-url}';
  const eE = config.eEntityId || '{entity-id}';
  const eO = config.eLogoutUrl || '{logout-url}';
  const userGrps = config.userGroups;
  const gid = userGrps[0]?.objId || '{group-id}';
  const now = new Date().toISOString().replace('T', ' ').slice(0, 19);

  return `========================================
AZURE ENTERPRISE APPLICATION SETUP
for FortiGate IPSEC VPN + SAML
FortiOS 7.4.11+
Generated by FortiGate Config Wizard: ${now}
========================================

NOTE: STREAMLINED SETUP FOR EXISTING GROUPS
  If your organization already has security groups for VPN users
  (most enterprises do), you can SKIP Steps 1-2 and start at Step 3.
  Just use your existing group's Object ID in the FortiGate config.

========================================

Step 1: Create Security Group for VPN Users (Skip if group exists)
  1. Microsoft Entra ID > Groups > New group
  2. Configure:
     Group type: Security
     Group name: VPN Users
     Membership type: Assigned
  3. Create, then COPY the Object ID: ${gid}

Step 2: Assign Users to the Group (Skip if using existing group)
  Open group > Members > Add members > Select users

Step 3: Create Enterprise Application
  1. Enterprise applications > New application
  2. Create your own application
  3. Name: FortiGate IPsec VPN
  4. Non-gallery > Create

Step 4: Configure Basic SAML
  1. Single sign-on > SAML
  2. Edit "Basic SAML Configuration":

     Identifier (Entity ID):
       https://${fq}:${pt}/remote/saml/metadata

     Reply URL (ACS):
       https://${fq}:${pt}/remote/saml/login

     Sign on URL:
       https://${fq}:${pt}/remote/saml/login

     Logout URL:
       https://${fq}:${pt}/remote/saml/logout

  3. Save

Step 5: Configure User Attributes & Claims
  Edit "User Attributes & Claims":

  Claim: username
    Add new claim > Name: username
    Source attribute: user.userprincipalname > Save

  Claim: group
    Add a group claim
    Groups assigned to the application
    Source attribute: Group ID
    Customize name: group > Save

Step 6: Configure SAML Signing
  Edit "SAML Signing Certificate":
    Signing Option: Sign SAML response and assertion
    Signing Algorithm: SHA-256 > Save

Step 7: Download Certificate
  Under "SAML Signing Certificate":
  Download: Certificate (Base64)

  >>> IMPORT this cert to FortiGate BEFORE
      applying CLI configuration <<<

Step 8: Assign Users/Groups
  Users and groups > Add user/group
  Select your VPN Users group > Assign

Step 9: Copy URLs for FortiGate
  From "Set up FortiGate IPsec VPN":

  Login URL:
    ${eL}

  Microsoft Entra Identifier:
    ${eE}

  Logout URL:
    ${eO}

========================================
VERIFICATION CHECKLIST
========================================
${userGrps.map((grp, idx) => `[ ] Group ${idx + 1} Object ID: ${grp.objId}`).join('\n')}
[ ] Certificate downloaded and imported
[ ] All URLs match FortiGate config
[ ] At least one user assigned to each group
[ ] SAML claims configured (username + group)
`;
}

// ---------------------------------------------------------------------------
// 4. FortiClient XML Generator
// ---------------------------------------------------------------------------
export function generateRemoteAccessXML(config: IPsecRemoteAccessConfig): string {
  const tunnels = config.tunnels;
  const psk = config.psk;
  const sm = config.splitMode;
  const sn = config.splitNets.split('\n').map(l => l.trim()).filter(Boolean);
  const nat = config.natTrav;
  const dpd = config.dpdOn;
  const di = config.dpdInt || '5';
  const dr = config.dpdRet || '3';
  const cl = config.childless;
  const sp = config.savePw;
  const ka = config.keepAlive;
  const p1p = config.p1p.length > 0 ? config.p1p : ['aes256-sha256'];
  const dh = config.p1d.join(';') || '19;20;21';
  const kl1 = config.p1kl || '86400';
  const p2p = config.p2p.length > 0 ? config.p2p : ['aes256-sha256'];
  const pfs = config.pfsOn;
  const pfdh = config.pfsDh || '19';
  const kl2 = config.p2kl || '43200';
  const dm = config.dnsMode;
  const d1 = config.dns1;

  // Convert proposal format from "aes256-sha256" to "AES256|SHA256" for FortiClient
  const convertProposal = (p: string): string => {
    const parts = p.split('-');
    if (parts.length === 2) {
      const enc = parts[0].toUpperCase().replace(/GCM|PRFSHA\d+/g, '');
      const hash = parts[1].toUpperCase().replace('SHA', 'SHA');
      return `${enc}|${hash}`;
    }
    return p.toUpperCase();
  };

  // Phase 1 proposals
  const p1Proposals = p1p.map(p => `            <proposal>${convertProposal(p)}</proposal>`).join('\n');

  // Phase 2 proposals
  const p2Proposals = p2p.map(p => `            <proposal>${convertProposal(p)}</proposal>`).join('\n');

  // Build remote networks for split tunneling
  let remoteNetworks = '';
  if (sm === 'enabled' && sn.length) {
    remoteNetworks = sn.map(cidr => {
      const [ip, mask] = cidr.split('/');
      const bits = parseInt(mask);
      const subnet = ~(0xffffffff >>> bits) >>> 0;
      const netmask = [(subnet >>> 24) & 255, (subnet >>> 16) & 255, (subnet >>> 8) & 255, subnet & 255].join('.');
      return `            <network>
                <addr>${ip}</addr>
                <mask>${netmask}</mask>
            </network>`;
    }).join('\n');
  } else {
    // Full tunnel - all traffic (0.0.0.0/0)
    remoteNetworks = `            <network>
                <addr>0.0.0.0</addr>
                <mask>0.0.0.0</mask>
            </network>`;
  }

  // DNS servers
  const dnsServer = dm === 'manual' && d1 ? d1 : '0.0.0.0';

  // Current date
  const now = new Date();
  const dateStr = `${now.getFullYear()}/${String(now.getMonth() + 1).padStart(2, '0')}/${String(now.getDate()).padStart(2, '0')}`;

  // Generate connection blocks for each tunnel
  const connections = tunnels.map(tunnel => {
    const tName = tunnel.name || 'Corporate-VPN';
    const tComments = tunnel.comments || '';
    const tFqdn = tunnel.fqdn || 'vpn.company.com';
    const tPort = tunnel.port || '10428';

    return `                <connection>
                    <name>${tName}</name>
                    <type>manual</type>
                    <ui>
                        <show_passcode>0</show_passcode>
                        <show_remember_password>${sp ? '1' : '0'}</show_remember_password>
                        <show_alwaysup>${ka ? '1' : '0'}</show_alwaysup>
                        <show_autoconnect>0</show_autoconnect>
                        <save_username>0</save_username>
                    </ui>
                    <ike_settings>
                        <version>2</version>
                        <prompt_certificate>0</prompt_certificate>
                        <description>${tComments}</description>
                        <server>${tFqdn}</server>
                        <authentication_method>Preshared Key</authentication_method>
                        <auth_data>
                            <preshared_key>${psk || '[ENTER_PSK_HERE]'}</preshared_key>
                        </auth_data>
                        <mode>aggressive</mode>
                        <dhgroup>${dh};</dhgroup>
                        <key_life>${kl1}</key_life>
                        <nat_traversal>${nat ? '1' : '0'}</nat_traversal>
                        <mode_config>1</mode_config>
                        <childless_mode>${cl ? '1' : '0'}</childless_mode>
                        <dpd>${dpd ? '1' : '0'}</dpd>
                        <dpd_retry_count>${dr}</dpd_retry_count>
                        <dpd_retry_interval>${di}</dpd_retry_interval>
                        <sso_enabled>1</sso_enabled>
                        <ike_saml_port>${tPort}</ike_saml_port>
                        <use_external_browser>0</use_external_browser>
                        <xauth>
                            <enabled>1</enabled>
                            <prompt_username>1</prompt_username>
                            <username />
                            <password />
                        </xauth>
                        <proposals>
${p1Proposals}
                        </proposals>
                    </ike_settings>
                    <ipsec_settings>
                        <remote_networks>
${remoteNetworks}
                        </remote_networks>
                        <dhgroup>${pfdh}</dhgroup>
                        <key_life_type>seconds</key_life_type>
                        <key_life_seconds>${kl2}</key_life_seconds>
                        <pfs>${pfs ? '1' : '0'}</pfs>
                        <use_vip>1</use_vip>
                        <virtualip>
                            <type>modeconfig</type>
                            <ip>0.0.0.0</ip>
                            <mask>0.0.0.0</mask>
                            <dnsserver>${dnsServer}</dnsserver>
                            <winserver>0.0.0.0</winserver>
                        </virtualip>
                        <proposals>
${p2Proposals}
                        </proposals>
                    </ipsec_settings>
                </connection>`;
  }).join('\n');

  let o = `<?xml version="1.0" encoding="UTF-8" ?>
<!-- Generated by FortiGate Config Wizard: ${dateStr} -->
<forticlient_configuration>
    <forticlient_version>7.4.3</forticlient_version>
    <version>7.4.3</version>
    <date>${dateStr}</date>
    <partial_configuration>0</partial_configuration>
    <os_version>windows</os_version>
    <vpn>
        <options>
            <on_os_start_connect />
            <autoconnect_tunnel />
            <keep_running_max_tries>0</keep_running_max_tries>
            <keep_running_delay>0</keep_running_delay>
            <allow_personal_vpns>1</allow_personal_vpns>
            <show_vpn_before_logon>0</show_vpn_before_logon>
        </options>
        <ipsecvpn>
            <options>
                <enabled>1</enabled>
                <usewincert>1</usewincert>
                <block_ipv6>1</block_ipv6>
            </options>
            <connections>
${connections}
            </connections>
        </ipsecvpn>
    </vpn>
</forticlient_configuration>`;

  // Show warning if no PSK entered
  if (!psk) {
    o = `<!-- WARNING: No Pre-Shared Key (PSK) entered!

     Enter your PSK in the "Advanced Options" section (Section 7)
     to generate a complete FortiClient configuration.

     Without the PSK, this file will contain a placeholder
     that must be manually replaced before importing.
-->\n\n` + o;
  }

  return o;
}
